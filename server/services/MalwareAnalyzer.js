const crypto = require('crypto');

class MalwareAnalyzer {
  static async analyze(url) {
    try {
      console.log(`ðŸ¦  Analyzing malware for ${url}`);
      
      // Always use mock data for lightweight backend
      const result = this.generateRealisticMockData(url);
      console.log(`âœ… Mock malware analysis completed for ${url} - Score: ${result.score}/100`);
      
      return result;

    } catch (error) {
      console.error(`âŒ Malware analysis failed for ${url}:`, error.message);
      return this.generateErrorResponse(error.message);
    }
  }

  static generateRealisticMockData(url) {
    try {
      const domain = new URL(url).hostname.toLowerCase();
      
      // Generate deterministic but varied results based on domain hash
      const domainHash = crypto.createHash('md5').update(domain).digest('hex');
      const seed = parseInt(domainHash.substring(0, 8), 16);
      
      // Seeded random function for consistent results
      const seededRandom = (seed) => {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
      };
      
      let malicious = 0;
      let total = 65 + Math.floor(seededRandom(seed) * 15); // 65-80 vendors
      
      // Risk assessment based on domain characteristics
      let riskLevel = 'clean';
      
      // High risk domains
      const highRiskPatterns = [
        /malware|virus|hack|phishing|spam|scam|fraud|trojan|botnet/i,
        /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/, // IP addresses
        /[a-z]{20,}\./, // Very long subdomains
        /[0-9]{8,}\./, // Long numeric domains
      ];
      
      // Medium risk domains  
      const mediumRiskPatterns = [
        /download|free|crack|keygen|serial|patch|warez/i,
        /bit\.ly|tinyurl|goo\.gl|t\.co|short\.link/i, // URL shorteners
        /-{2,}|_{2,}/, // Multiple dashes/underscores
      ];
      
      // Low risk domains
      const lowRiskPatterns = [
        /test|demo|staging|dev|localhost/i,
        /\.edu|\.gov|\.org$/i,
      ];
      
      // Determine risk level
      if (highRiskPatterns.some(pattern => pattern.test(domain))) {
        riskLevel = 'high';
        malicious = 8 + Math.floor(seededRandom(seed * 2) * 20); // 8-28 detections
      } else if (mediumRiskPatterns.some(pattern => pattern.test(domain))) {
        riskLevel = 'medium';
        malicious = 2 + Math.floor(seededRandom(seed * 3) * 8); // 2-10 detections
      } else if (lowRiskPatterns.some(pattern => pattern.test(domain))) {
        riskLevel = 'low';
        malicious = Math.floor(seededRandom(seed * 4) * 2); // 0-1 detections
      } else {
        // Normal domains
        const riskFactor = seededRandom(seed * 5);
        if (riskFactor < 0.85) {
          malicious = 0; // 85% clean
        } else if (riskFactor < 0.95) {
          malicious = 1; // 10% with 1 detection
        } else {
          malicious = 2; // 5% with 2 detections
        }
      }

      // Generate vendor detections
      const mockVendors = [];
      if (malicious > 0) {
        const allVendors = [
          'Kaspersky', 'Bitdefender', 'Avira', 'ESET-NOD32', 'Symantec', 'McAfee',
          'Trend Micro', 'F-Secure', 'Sophos', 'Malwarebytes', 'ClamAV', 'DrWeb',
          'G-Data', 'Panda', 'Quick Heal', 'Zillya', 'Fortinet', 'Cyren',
          'Rising', 'Jiangmin', 'K7GW', 'K7AntiVirus', 'TheHacker', 'Arcabit',
          'Baidu', 'VBA32', 'Zoner', 'Tencent', 'Yandex', 'Ikarus',
          'GData', 'Commtouch', 'ByteHero', 'Vipre', 'ViRobot', 'nProtect',
          'CAT-QuickHeal', 'ALYac', 'MAX', 'Ad-Aware', 'Emsisoft', 'Comodo'
        ];
        
        // Shuffle vendors based on seed for consistent results
        const shuffledVendors = allVendors.sort((a, b) => {
          return seededRandom(seed + a.charCodeAt(0)) - 0.5;
        });
        
        const detectionTypes = {
          high: ['Trojan.Generic', 'Malware.Suspicious', 'Backdoor.Agent', 'Worm.AutoRun', 'Rootkit.Hidden'],
          medium: ['PUP.Optional', 'Adware.Generic', 'Suspicious.Behavior', 'Riskware.Tool'],
          low: ['Suspicious.Cloud', 'Heuristic.Suspicious']
        };
        
        const typeArray = detectionTypes[riskLevel] || detectionTypes.low;
        
        for (let i = 0; i < Math.min(malicious, shuffledVendors.length); i++) {
          const vendor = shuffledVendors[i];
          const detectionType = typeArray[Math.floor(seededRandom(seed + i) * typeArray.length)];
          const version = `${Math.floor(seededRandom(seed + i + 100) * 5) + 1}.${Math.floor(seededRandom(seed + i + 200) * 10)}.${Math.floor(seededRandom(seed + i + 300) * 100)}`;
          
          mockVendors.push({
            name: vendor,
            detected: true,
            result: detectionType,
            category: 'malicious',
            engine_name: vendor,
            engine_version: version,
            update: new Date(Date.now() - Math.floor(seededRandom(seed + i + 400) * 7 * 24 * 60 * 60 * 1000)).toISOString()
          });
        }
      }

      // Generate categories based on risk level
      const categories = [];
      switch (riskLevel) {
        case 'high':
          categories.push('malware', 'trojan', 'suspicious', 'confirmed-timeout');
          break;
        case 'medium':
          categories.push('suspicious', 'pup', 'adware');
          break;
        case 'low':
          if (malicious > 0) categories.push('suspicious');
          break;
      }

      // Calculate reputation score
      const reputation = this.calculateReputation(malicious, total, riskLevel);

      return {
        malicious: malicious,
        total: total,
        vendors: mockVendors,
        categories: categories,
        lastAnalysisDate: new Date(Date.now() - Math.floor(seededRandom(seed * 6) * 24 * 60 * 60 * 1000)).toISOString(),
        reputation: reputation,
        score: this.calculateMalwareScore(malicious, total),
        details: {
          method: 'mock_virustotal_v3',
          scanId: `mock_${domainHash.substring(0, 16)}`,
          permalink: `https://www.virustotal.com/gui/url/${Buffer.from(url).toString('base64').replace(/[+/=]/g, '')}`,
          responseCode: 1,
          riskLevel: riskLevel,
          stats: {
            malicious: malicious,
            clean: Math.max(0, total - malicious - Math.floor(seededRandom(seed * 7) * 3)),
            suspicious: Math.floor(seededRandom(seed * 8) * 2),
            undetected: Math.floor(seededRandom(seed * 9) * 5),
            timeout: Math.floor(seededRandom(seed * 10) * 2)
          },
          scan_date: new Date().toISOString(),
          verbose_msg: "Scan finished, information embedded"
        }
      };
    } catch (error) {
      // Fallback for invalid URLs
      return {
        malicious: 0,
        total: 67,
        vendors: [],
        categories: [],
        lastAnalysisDate: new Date().toISOString(),
        reputation: 0,
        score: 100,
        details: {
          method: 'mock_fallback',
          error: 'Invalid URL format',
          scanId: `fallback_${Date.now()}`,
          responseCode: 0
        }
      };
    }
  }

  static calculateMalwareScore(malicious, total) {
    if (total === 0) return 100;
    
    const percentage = (malicious / total) * 100;
    
    if (percentage === 0) return 100;
    if (percentage <= 5) return 85;
    if (percentage <= 10) return 70;
    if (percentage <= 20) return 50;
    if (percentage <= 35) return 30;
    if (percentage <= 50) return 15;
    return 0;
  }

  static calculateReputation(malicious, total, riskLevel) {
    if (total === 0) return 0;
    
    const percentage = (malicious / total) * 100;
    
    if (percentage === 0) {
      // Clean sites get positive reputation
      return Math.floor(Math.random() * 15) + 5; // 5 to 20
    } else if (percentage < 5) {
      return Math.floor(Math.random() * 10) - 5; // -5 to 5
    } else if (percentage < 15) {
      return Math.floor(Math.random() * 20) - 30; // -30 to -10
    } else if (percentage < 30) {
      return Math.floor(Math.random() * 20) - 50; // -50 to -30
    } else {
      return Math.floor(Math.random() * 30) - 90; // -90 to -60
    }
  }

  static generateErrorResponse(errorMessage) {
    return {
      error: errorMessage,
      malicious: 0,
      total: 0,
      vendors: [],
      categories: [],
      lastAnalysisDate: null,
      reputation: 0,
      score: 0,
      details: {
        method: 'error_fallback',
        error: errorMessage,
        responseCode: -1
      }
    };
  }

  // Additional mock methods for completeness
  static generateThreatIntelligence(url) {
    const threats = {
      high: [
        { type: 'Malware Distribution', severity: 'Critical', description: 'Known to distribute malicious software' },
        { type: 'Phishing Campaign', severity: 'High', description: 'Used in credential theft attacks' },
        { type: 'C&C Server', severity: 'Critical', description: 'Command and control infrastructure' }
      ],
      medium: [
        { type: 'PUP Distribution', severity: 'Medium', description: 'Distributes potentially unwanted programs' },
        { type: 'Suspicious Behavior', severity: 'Medium', description: 'Exhibits unusual network patterns' },
        { type: 'Ad Injection', severity: 'Low', description: 'Injects unwanted advertisements' }
      ],
      low: []
    };

    return threats;
  }
}

module.exports = MalwareAnalyzer;