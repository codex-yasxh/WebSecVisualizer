const axios = require('axios');
const crypto = require('crypto');

class MalwareAnalyzer {
  static async analyze(url) {
    try {
      console.log(`🦠 Analyzing malware for ${url}`);
      
      const result = {
        malicious: 0,
        total: 0,
        vendors: [],
        categories: [],
        lastAnalysisDate: null,
        reputation: 0,
        score: 0,
        details: {}
      };

      // Try VirusTotal API if available
      if (process.env.VIRUSTOTAL_API_KEY) {
        const vtResult = await this.checkVirusTotal(url);
        if (vtResult) {
          return vtResult;
        }
      }

      // Fallback to basic checks
      const basicResult = await this.performBasicChecks(url);
      return basicResult;

    } catch (error) {
      console.error(`❌ Malware analysis failed for ${url}:`, error.message);
      return {
        error: error.message,
        malicious: 0,
        total: 0,
        vendors: [],
        categories: [],
        lastAnalysisDate: null,
        reputation: 0,
        score: 0,
        details: {}
      };
    }
  }

  static async checkVirusTotal(url) {
    try {
      const apiKey = process.env.VIRUSTOTAL_API_KEY;
      const urlId = crypto.createHash('sha256').update(url).digest('hex');

      // Check if URL has been analyzed before
      const checkResponse = await axios.get(`https://www.virustotal.com/vtapi/v2/url/report`, {
        params: {
          apikey: apiKey,
          resource: url
        },
        timeout: 10000
      });

      if (checkResponse.data.response_code === 1) {
        const data = checkResponse.data;
        
        return {
          malicious: data.positives || 0,
          total: data.total || 0,
          vendors: this.extractVendorInfo(data.scans || {}),
          categories: data.categories || [],
          lastAnalysisDate: data.scan_date,
          reputation: data.reputation || 0,
          score: this.calculateMalwareScore(data.positives, data.total),
          details: {
            scanId: data.scan_id,
            permalink: data.permalink,
            responseCode: data.response_code
          }
        };
      } else {
        // URL not found, submit for scanning
        return await this.submitToVirusTotal(url, apiKey);
      }

    } catch (error) {
      console.error('VirusTotal API error:', error.message);
      return null;
    }
  }

  static async submitToVirusTotal(url, apiKey) {
    try {
      const submitResponse = await axios.post('https://www.virustotal.com/vtapi/v2/url/scan', {
        url: url,
        apikey: apiKey
      }, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        timeout: 10000
      });

      if (submitResponse.data.response_code === 1) {
        // Wait a bit and check again
        await new Promise(resolve => setTimeout(resolve, 2000));
        return await this.checkVirusTotal(url);
      }

      return null;

    } catch (error) {
      console.error('VirusTotal submission error:', error.message);
      return null;
    }
  }

  static extractVendorInfo(scans) {
    const vendors = [];
    
    for (const [vendorName, scanResult] of Object.entries(scans)) {
      if (scanResult.detected) {
        vendors.push({
          name: vendorName,
          detected: scanResult.detected,
          result: scanResult.result,
          update: scanResult.update
        });
      }
    }

    return vendors;
  }

  static async performBasicChecks(url) {
    const result = {
      malicious: 0,
      total: 0,
      vendors: [],
      categories: [],
      lastAnalysisDate: new Date().toISOString(),
      reputation: 0,
      score: 0,
      details: {
        method: 'basic_checks',
        checks: []
      }
    };

    const checks = [];

    // Check for suspicious patterns in URL
    const suspiciousPatterns = [
      /\.tk$/i,
      /\.ml$/i,
      /\.ga$/i,
      /\.cf$/i,
      /\.gq$/i,
      /bit\.ly/i,
      /tinyurl\.com/i,
      /goo\.gl/i,
      /t\.co/i
    ];

    const suspiciousPattern = suspiciousPatterns.find(pattern => pattern.test(url));
    if (suspiciousPattern) {
      checks.push({
        type: 'suspicious_domain',
        description: 'URL contains suspicious domain pattern',
        risk: 'medium'
      });
      result.malicious += 1;
    }

    // Check for suspicious keywords
    const suspiciousKeywords = [
      'login',
      'signin',
      'bank',
      'paypal',
      'secure',
      'update',
      'verify',
      'confirm',
      'account',
      'password'
    ];

    const urlLower = url.toLowerCase();
    const foundKeywords = suspiciousKeywords.filter(keyword => 
      urlLower.includes(keyword)
    );

    if (foundKeywords.length > 2) {
      checks.push({
        type: 'suspicious_keywords',
        description: `URL contains multiple suspicious keywords: ${foundKeywords.join(', ')}`,
        risk: 'medium'
      });
      result.malicious += 1;
    }

    // Check for IP address instead of domain
    const ipPattern = /^(https?:\/\/)?(\d{1,3}\.){3}\d{1,3}/i;
    if (ipPattern.test(url)) {
      checks.push({
        type: 'ip_address',
        description: 'URL uses IP address instead of domain name',
        risk: 'high'
      });
      result.malicious += 2;
    }

    // Check for excessive subdomains
    const domain = new URL(url).hostname;
    const subdomainCount = domain.split('.').length - 2;
    if (subdomainCount > 3) {
      checks.push({
        type: 'excessive_subdomains',
        description: `URL has ${subdomainCount} subdomains (suspicious)`,
        risk: 'medium'
      });
      result.malicious += 1;
    }

    // Check for non-standard ports
    const urlObj = new URL(url);
    if (urlObj.port && !['80', '443', '8080', '8443'].includes(urlObj.port)) {
      checks.push({
        type: 'non_standard_port',
        description: `URL uses non-standard port: ${urlObj.port}`,
        risk: 'low'
      });
      result.malicious += 1;
    }

    // Check for URL encoding
    if (url !== decodeURIComponent(url)) {
      checks.push({
        type: 'url_encoding',
        description: 'URL contains encoded characters (potential obfuscation)',
        risk: 'medium'
      });
      result.malicious += 1;
    }

    result.details.checks = checks;
    result.total = Math.max(5, result.malicious + 2); // Minimum total for basic checks
    result.score = this.calculateMalwareScore(result.malicious, result.total);

    // Add basic vendor simulation
    if (result.malicious > 0) {
      result.vendors.push({
        name: 'WebSec-Basic',
        detected: true,
        result: 'Suspicious URL patterns detected',
        update: new Date().toISOString()
      });
    }

    return result;
  }

  static calculateMalwareScore(malicious, total) {
    if (total === 0) return 0;
    
    const percentage = (malicious / total) * 100;
    
    if (percentage === 0) return 100;
    if (percentage <= 10) return 80;
    if (percentage <= 25) return 60;
    if (percentage <= 50) return 40;
    if (percentage <= 75) return 20;
    return 0;
  }
}

module.exports = MalwareAnalyzer; 